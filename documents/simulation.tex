\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{physics}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
%\usepackage[round]{natbib}
%\bibliographystyle{unsrtnat}

% this just sets up the page size and margins
\setlength{\topmargin}{0pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\setlength{\headheight}{0pt}

% create some short cut commands
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bu}{\boldsymbol{u}}


% this is a bunch of stuff that allows python style code snippits
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal
% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\setcounter{MaxMatrixCols}{15}


\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
		language=Python,
		basicstyle=\ttm,
		morekeywords={self},              % Add keywords here
		keywordstyle=\ttb\color{deepblue},
		emph={MyClass,__init__},          % Custom highlighting
		emphstyle=\ttb\color{deepred},    % Custom highlighting style
		stringstyle=\color{deepgreen},
		frame=tb,                         % Any extra options here
		showstringspaces=false,
		tabsize=4
}}

\newcommand{\mpc}{\textsc{mpc}}
\newcommand{\nmpc}{\textsc{nmpc}}

% Python environment
\lstnewenvironment{python}[1][]
{
	\pythonstyle
	\lstset{#1}
}
{}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}

\title{Comparison of Direct Methods for NMPC  Applied to  a Thrust Vector Drone}
\author{Izzy Mones and Heidi Dixon}
%\date{}

\begin{document}
	\maketitle
	
	\section*{Introduction}	
	\begin{enumerate}
		\item What is a Thrust Vector Drone and Why they are useful for Rocket Design
	\end{enumerate}
	

	
	\section*{Thrust Vector Drone Equations of Motion}
	
	The system state and control variables are defined as follows, the state $\vec{x}$ includes translational position $x, y,  z $ and velocity $v_x, v_y, v_z $  in the world frame, the attitude represented as a unit quaternion $q_x, q_y,  q_z, q_w$ , and the angular velocity in the body frame $ \omega_x, \omega_y, \omega_z$. The control variables include the two gimbal angles $\theta_1, \theta_2 $, the average thrust between the two propellers $T_{avg}$ and the differential thrust between the propellers $T_{diff}$ to control the rotation about the body z axis.
        \[
        \vec{x} =
        \begin{bmatrix}
        x \\ y \\ z \\ v_x \\ v_y \\ v_z \\ q_x \\ q_y \\ q_z \\ q_w \\ \omega_x \\ \omega_y \\ \omega_z
        \end{bmatrix}
        \qquad
        \vec{u} =
        \begin{bmatrix}
        \theta_1 \\ \theta_2 \\ T_{avg} \\ T_{diff}
        \end{bmatrix}
        \]
        The equations of motion are represented as a series of first-order vector differential equations:
        	\[
		\dot{\vec{p}} = \vec{v}
	\]
	\[
		\dot{\vec{v}} = \frac{1}{m}R(\vec{q})\vec{F_b}+\vec{g}
	\]
	\[
		\dot{\vec{q}} = \frac{1}{2}Q(\vec{\omega})\vec{q}
	\]
	\[
		\dot{\vec{\omega}} = I^{-1}\!\left(\vec{M_b} - \vec{\omega} \times (I\,\vec{\omega})\right)
	\]
	Using vector decomposition we can find the thrust vector in body coordinates in terms of the control variables $\theta_1$ and $\theta_2$.	
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{graph3d.jpg}
	\caption{Three-dimensional thrust decomposition for a 2-axis gimballed drone.}
	\label{fig:3dgraph}
	\end{figure}
        \begin{figure}[H]
        	\centering
        	\begin{subfigure}[b]{0.48\textwidth}
        		\centering
        		\includegraphics[width=\textwidth]{graph2.jpg}
        		\caption{Thrust decomposition in the inner gimbal axis plane.}
        	\end{subfigure}
        	\begin{subfigure}[b]{0.48\textwidth}
        		\centering
        		\includegraphics[width=\textwidth]{graph3.jpg}
        		\caption{Thrust decomposition in the xâ€“z plane.}
        	\end{subfigure}
        	\caption{Two-dimensional thrust decompositions for a 2-axis gimballed drone.}
        	\label{fig:3dDecomp}
        \end{figure}

	 \[
         \vec{F_b} = T
        \begin{bmatrix}
        \sin{\theta_2}  \\
         -\sin{\theta_1}\cos{\theta_2}  \\
         \cos{\theta_1}\cos{\theta_2}
        \end{bmatrix}
        \]
$\vec{M_z}$ is the moment about the body z axis due to differential thrust.
        \[
	\vec{M_z} =
        \begin{bmatrix}
        0  \\
        0  \\
        M_z
        \end{bmatrix}
        \]
The body frame moment vector is the sum of the torque due to thrust vector acting through the moment arm and the torque generated by the differential thrust.
        \[
	\vec{l} =
        \begin{bmatrix}
        0  \\
        0  \\
        -l
        \end{bmatrix}
        \]
        	 \[
        \vec{M_b} = \vec{l} \times \vec{F_b} + \vec{M_z}=       
        \begin{bmatrix}
        -lT\sin{\theta_1}\cos{\theta_2}  \\
        -lT\sin{\theta_2}  \\
	M_z
        \end{bmatrix}
        \]
The drone is designed to be symmetrical and the principal axes align with the body frame. The products of inertia vanish and inertia tensor can be written with only diagonal terms.
         \[
        I =
        \begin{bmatrix}
        I_{xx} & 0 &0 \\
        0 & I_{yy }& 0 \\
        0 & 0 & I_{zz}
        \end{bmatrix}
        \]
The body to world matrix is used to compute the force in world coordinates due to the body-centric thrust vector given the quaternion orientation.
        \[
        R(\vec{q}) =
        \begin{bmatrix}
        1 - 2(q_y^2 + q_z^2) & 2(q_x q_y - q_w q_z) & 2(q_x q_z + q_w q_y) \\
        2(q_x q_y + q_w q_z) & 1 - 2(q_x^2 + q_z^2) & 2(q_y q_z - q_w q_x) \\
        2(q_x q_z - q_w q_y) & 2(q_y q_z + q_w q_x) & 1 - 2(q_x^2 + q_y^2)
        \end{bmatrix}
        \]
The quaternion propagation matrix computes the change in quaternions given a set of angular velocities.
        \[
        Q(\vec{\omega}) =
        \begin{bmatrix}
        0 & \omega_z & -\omega_y & \omega_x \\
        -\omega_z & 0 & \omega_x & \omega_y \\
        \omega_y & -\omega_x & 0 & \omega_z \\
        -\omega_x & -\omega_y & -\omega_z & 0
        \end{bmatrix}
	\]
	The final extended dynamic equations are expressed as:
	\[
		\dot{x} = v_x
	\]
	\[
		\dot{y} = v_y
	\]
	\[
		\dot{z} = v_z
	\]
	\[
		\dot{v_x} = \frac{\sin{\theta_2} *T(1 - 2(q_y^2 + q_z^2))-\sin{\theta_1}\cos{\theta_2}*2T(q_x q_y - q_w q_z)+\cos{\theta_1}\cos{\theta_2}* 2T(q_x q_z + q_w q_y)}{m}
	\]
	\[
		\dot{v_y} =\frac{\sin{\theta_2} *2T(q_x q_y + q_w q_z)-\sin{\theta_1}\cos{\theta_2}*T(1 - 2(q_x^2 + q_z^2))+\cos{\theta_1}\cos{\theta_2}* 2T(q_y q_z - q_w q_x)}{m}+g
	\]
	\[
		\dot{v_z} = \frac{\sin{\theta_2} *2T(q_x q_z - q_w q_y-\sin{\theta_1}\cos{\theta_2}* 2T(q_y q_z + q_w q_x)+\cos{\theta_1}\cos{\theta_2}* T(1 - 2(q_x^2 + q_y^2))}{m}
	\]
	\[
		\dot{q_x} = \frac{\omega_z q_y-\omega_y q_z+ \omega_x q_w}{2}
	\]
	\[
		\dot{q_y} = \frac{-\omega_z q_x+\omega_x q_z+ \omega_y q_w}{2}
	\]
	\[
		\dot{q_z} =  \frac{\omega_y q_x-\omega_x q_y+ \omega_z q_w}{2}
	\]
	\[
		\dot{q_w} =  \frac{-\omega_x q_x - \omega_y q_y - \omega_z q_z}{2}
	\]
	\[
		\dot{\omega_x} = \frac{-lT\sin{\theta_1}\cos{\theta_2}-\omega_y\omega_zI_{zz} + \omega_y\omega_zI_{yy}}{I_{xx}}
	\]
	\[
		\dot{\omega_y} = \frac{-lT\sin{\theta_2}-\omega_x\omega_zI_{xx} + \omega_x\omega_zI_{zz}}{I_{yy}}
	\]
	\[
		\dot{\omega_z} =  \frac{M_z -\omega_x\omega_yI_{yy} + \omega_x\omega_yI_{xx}}{I_{zz}}
	\]

	The average thrust and differential thrust control variables are defined as the average of and difference between the two propeller thrust values. 
	\[
		T_{avg} =\frac{T_1+T_2}{2}
	\]
	\[
		T_{diff} =T_1-T_2
	\]
$T_1$ and $T_2$ denote the normalized brushless motor command signals, ranging from 0 (no throttle) to 1 (full throttle).
	\[
		T_1 = T_{avg} + T_{diff}/2
	\]
	\[
		T_2 = T_{avg} - T_{diff}/2
	\]
To map the average thrust command signal value to the actual thrust force value in newtons used in the thrust-vector decomposition a second-order polynomial fit is experimentally determined. Similarly, a linear relationship is used to map the differential thrust to the moment about the body frame z axis.
	\[
		T = aT_{avg}^2+bT_{avg}+c
	\]
	\[
		M_z = d I_{zz} T_{diff}
	\]

	


	\section*{NMPC}

Model predictive control (\mpc) is a control algorithm that solves a linear optimization problem at each time step. 
The set of instance constraints can be used to enforce the equations of motion and restrict the values of control inputs or state variables.  For example, {\mpc} constraints can be used to eliminate solutions that violate minimum or maximum control values or require control values to change faster than mechanically possible.  This gives {\mpc} algorithms more control over the types of solutions produced than linear quadratic regulators (LQR) or proportional integral derivative (PID) controllers.  
Unlike LQR and PID methods which are designed to find an optimal control input for a given moment in time, an {\mpc} solution considers a series of control inputs over a finite time horizon.  This allows {\mpc} solutions to create a {\em plan} of actions that can anticipate and adjust to future issues. For example, the optimal speed for a car at a given instance might change if the algorithm knew that it was entering a curve in the road in the next few time steps.
The ability to anticipate future conditions allows {\mpc} to construct more robust solutions. The control plan is rebuilt at each timestep allowing the method to react to disturbances and noise.
Nonlinear model predictive control (\nmpc) is a variant of {\mpc} that allows nonlinear constraints. 

The biggest advantage of using {\nmpc} to control our thrust vector drone is the allowance of nonlinear constraints. 
The 6DOF equations of motion that describe our dynamics are strongly nonlinear.  An LQR or {\mpc} method  requires a linear model. The 6DOF equations can be linearized around the fixed point in which the drone is vertically balanced, however, the linearized equations quickly become inaccurate if the drone moves away from the fixed point.  Working directly with the nonlinear equations allows more accurate predictions of the drone state. Like {\mpc}, {\nmpc}  allows us to enforce the mechanical limitations of our thrust motors and gimbal servos.


A prime drawback of {\mpc} and {\nmpc} algorithms over LQR and PID  is their higher computational cost.  To use {\nmpc} to control a thrust vector drone, we need to solve an {\nmpc} instance in less than $0.02$ seconds on a Raspberry Pi 5.  Given an {\nmpc} problem instance, there are a variety of known ways to formulate the instance as nonlinear programming problem.  Here we give our {\nmpc} problem instance and present three different ways to formulate this instance as a nonlinear programming problem.  We then compare the quality of  solutions produced and their relative computational efficiency.

To use {\nmpc} the problem instance needs to be parameterized over the control trajectory, the differential equations for the system dynamics need to be integrated forward, and then the resulting problem can be optimized over control parameters. There are different ways to parameterize the problem and integrate it.  These choices will affect the size of the problem and the speed at which it can be solved. Also the accuracy of the solution.



        \[
        \min_{u(t)} \; \int_{t_0}^{t_f} \ell(x,u,t)\,dt \;+\; \phi(x_f)
        \]
        \[
	\ell(x,u,t) = (x(t)-x_{ref})^T Q (x(t)-x_{ref}) + (u(t)-u_{ref})^T R (u(t)-u_{ref}) 
        \]
        \[
	\phi(x_f) = (x(t_f)-x_{ref})^T Q_f (x(t_f)-x_{ref})
        \]
        \[
	-\theta_{max} \leq \theta_1 \leq \theta_{max}
        \]
        \[
	-\theta_{max} \leq \theta_2 \leq \theta_{max}
        \]
        \[
        	-\dot{\theta}_{max} \leq \dot{\theta}_1 \leq \dot{\theta}_{max}
        \]
        \[
        	-\dot{\theta}_{max} \leq \dot{\theta}_2 \leq \dot{\theta}_{max}
        \]
        \[
        	T_{min}  \leq T_{avg} + T_{diff}/2 \leq T_{max}
        \]
        \[
        T_{min} \leq  T_{avg} - T_{diff}/2 \leq T_{max}
        \]
        \[
        T_{diff_{min}} \leq T_{diff} \leq T_{diff_{max}}
        \]
        \[
        0 \leq z
        \]
        
\section{Direct Methods}
\subsection*{Orthogonal Collocation using {do-mpc}} 
Orthogonal collocation is a local method that divides the time horizon into finite elements and fits polynomials to each interval. The dynamics are enforced throughout each interval at a set of Radau nodes given by:
        \[
        \gamma_0=1,  \qquad \gamma_j = \gamma_{j-1} \frac{(K-j+1)(K+j+\alpha+\beta)}{j(j+\beta)}, \qquad j = 1,\ldots,K
        \]
When $P_K$ are the Gauss-Jacobi polynomials:
        \[
        P_K^{(\alpha, \beta)}(\tau) = \sum_{j=0}^{K}(-1)^{K-j}\gamma_j\tau^j
        \]
Lagrange polynomials, $\ell_j(\tau)$, are used to interpolate the state trajectory $z^K(\tau)$:
        \[
	\ell_j(\tau)=\prod_{\substack{m=0 \\ m\neq j}}^{K}\frac{\tau-\tau_m}{\tau_j-\tau_m}
        \]        
        \[
	z^K(\tau)=\sum_{j=0}^{K}z_{ij}\ell_j(\tau)
        \]
By differentiating the state trajectory and equating it with the dynamics ODEs, $f$, a dynamics constraint is formed:
        \[
        \sum_{j=0}^K z_{ij}\frac{d\ell_j(\tau_k)}{d\tau}=h_if(z_{ik},t_{ik}), 
        \qquad k=1,\dots,K.
        \]
Continuity constraints are used to fit an interval polynomial's endpoint with the first point of the next interval. There are two additional continuity constraints for enforcing the overall horizon's start and endpoint continuity.
        \[
	z_{i+1,0}=\sum_{j=0}^{K}\ell_j(1)z^{ij}
        \]
        \[
	z_f=\sum_{j=0}^{K}\ell_j(1)z^{Nj}, \qquad z_{1,0} = z_0
        \]
        The cost function is defined as:
        \[
        	\substack{min \\ i(\cdot)}J=\Phi(z(t_f),t_f) + \int_{t_0}^{t_f}L(z(t),u(t),t)dt
        \]
        \[
        J=\Phi(z(t_f)) + \sum_{i=1}^{N}h_i\sum_{k=1}^{K}\omega_kL(z_{ik},u_{ik},t_{ik})
        \]
Where the weights $\omega_k$ are determined by Radau quadrature, which integrates all polynomials up to $2s-1$. For a horizon of 100 time steps each with an interpolant polynomial order of two the total number of decision variables per time step is $13*(100*(2+1)+1)+4*100=4313.$

\subsection*{Multiple Shooting (with Rungeâ€“Kutta discretization)}
For multiple shooting, we divide our time horizon into $N$ evenly spaced nodes $\{ t_0, t_1, \ldots, t_N \}$ of length $\Delta t$. The initial state is constrained and at each node we make a copy of our state $x_k$ and control $u_k$ variables. Within each time step $[ t_k, t_{k+1}]$ we forward integrate our differential equations $f$ using Runge-Kutta to create a constraint that enforces the change of state between time steps with the system dynamics. 

        \begin{eqnarray}
        \nonumber
        x_0 & = & X_0 \\[6pt] \nonumber
        k_1 & = & f(x_k, u_k, t_k), \\[6pt] \nonumber
        k_2 & = & f\!\left(x_k + \tfrac{\Delta t}{2} k_1,\, u_k,\, t_k + \tfrac{\Delta t}{2}\right), \\[6pt] \nonumber
        k_3 & = & f\!\left(x_k + \tfrac{\Delta t}{2} k_2,\, u_k,\, t_k + \tfrac{\Delta t}{2}\right), \\[6pt] \nonumber
        k_4 & = & f\!\left(x_k + \Delta t\, k_3,\, u_k,\, t_k + \Delta t\right), \\[10pt]
        x_{k+1} - \Big(x_k + \tfrac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\Big) &=& 0, 
        \qquad k = 0,\dots, N-1.
        \label{eq:rkstate}
        \end{eqnarray}
        
The cost function is defined to penalize deviation from reference state as well as deviation from reference control input. There is also a terminal cost that incentivizes long term stability by weighting the final state more heavily.
        \[
        \vec{x}_r =
        \begin{bmatrix}
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0
        \end{bmatrix}^{\!T},
        \qquad
        \vec{u}_r =
        \begin{bmatrix}
        0 & 0 & T_{\text{hover}} & 0
        \end{bmatrix}^{\!T}.
        \]
         \begin{equation}
         	 \sum_{k=0}^{N-1}  \Big[(x_k -  x_{r})^T Q (x_k - x_{r}) + (u_k -  u_{r})^T R (u_k - u_{r}) \Big] + (x_N -  x_{r})^T Q_f (x_N - x_{r})
         \end{equation}
Multiple shooting considers the state and control variables at every time step to be optimization variables so the full NLP vector is:
        \[
        \begin{bmatrix}
        x_0 & u_0 & x_1 & u_1 & ... & x_{N-1} & u_{N-1} & x_N
        \end{bmatrix}
        \]
This can easily become computationally demanding for long horizons and high-dimensional systems. For a horizon length of 100 time steps there are $13 * (100+1)+4*100=1713$ decision variables per time step.
 
\subsection*{Chebyshev Pseudospectral Method}
Multiple shooting is useful for its robustness to discontinuities and nonlinearity and its conceptual simplicity. However, thrust-vectoring dynamics are smooth and continuous, so many of the benefits of multiple shooting are unnecessary. Additionally, multiple shooting introduces a much larger NLP because it solves for the state and control variables at every point in the control horizon. By contrast, Chebyshev Pseudospectral Collocation is a global method that represents the trajectory of each state with a single interpolating polynomial of degree $N$ over the entire horizon, defined by its values at a set of $N+1$ nodes. It achieves spectral accuracy, with error decreasing exponentially as the number of nodes increases, while requiring far fewer decision variables than multiple shooting. For $N=6$ there are seven nodes and $7*13+7*4=119$ decision variables per time step. The dynamics are enforced by constraining the derivative of the interpolant at each node to the dynamic equations. Chebyshevâ€“Gaussâ€“Lobatto nodes are used to cluster more of the nodes towards the beginning and end of the horizon, mitigating the Runge Phenomenon, where polynomial interpolation develops large oscillations near the endpoints. The cosine distribution ensures accuracy and stability:
	\[
        \tau_j = \cos{(\frac{j\pi}{N})},\qquad j = 0,1,...,N
        \]
 These node values are defined from 1 to -1 instead of from time 0 to the end of the horizon. To determine the horizon time for a given tau a linear mapping is used:
         \[
        t(\tau) = \frac{t_f-t_0}{2}\,\tau + \frac{t_f+t_0}{2}, 
        \qquad 
        \frac{dt}{d\tau} = \frac{t_f-t_0}{2}.
        \]
        \[
        \frac{dx}{dt}=\frac{d\tau}{dt}\frac{dx}{d\tau}=\frac{2}{t_f-t_0}\frac{dx}{d\tau}
        \]
At each time step the dynamics are checked with:
        \[
        \frac{dx}{d\tau}(\tau_j) \;\approx\; \sum_{j=0}^N D_{ij}\,x(\tau_j), 
        \qquad i=0,\dots,N.
        \]
Using the chain rule the $\tau$ and time derivatives can be related allowing the node differentiation matrix to be checked against the system dynamics $f(x_i,u_i)$.
        \[
       \dot{x}(t_j)= \frac{2}{t_f-t_0}\sum_{j=0}^N D_{ij}\,x(\tau_j), 
        \]
        \[
        \sum_{j=0}^N D_{ij}\,x_j 
        = \frac{t_f-t_0}{2}\, f(x_i,u_i), 
        \qquad i=1,\dots,N-1.
        \]
Where D is a Chebyshev Differentiation Matrix defined by:
	\[
       D_{N_{00}}=\frac{2N^2+1}{6}
        \]
	\[
       D_{N_{jj}}=\frac{-x_j}{2(1-x_j^2)}
        \]
	\[
       D_{N_{ij}}=\frac{c_i}{c_j}\frac{(-1)^{i+j}}{x_i-x_j}
        \]
	\[
       D_{N_{NN}}=-\frac{2N^2+1}{6}
        \]
	\[
        c_{i/j}=
        \begin{cases}
        2 & i/j = 0 \;\text{or}\; N, \\
        1 & \text{otherwise}.
        \end{cases}
        \]
For $N=6$ the differentiation matrix is:
        \[
        D_{6} =
        \begin{bmatrix}
        \frac{73}{6} & -(8+4\sqrt{3})  & 4 & -2 & \frac{4}{3} & 4\sqrt{3} - 8 & \frac{1}{2}\\
        2+\sqrt{3} & -\sqrt{3} & -(1+\sqrt{3}) & \frac{2}{\sqrt{3}} & 1-\sqrt{3} & \frac{1}{\sqrt{3}} & \frac{1-\sqrt{3}}{1+\sqrt{3}}\\
        -1 & 1+\sqrt{3} & -\frac{1}{3} & -2 & 1 & 1-\sqrt{3} & \frac{1}{3}\\
        \frac{1}{2} & -\frac{2}{\sqrt{3}} & 2 & 0 & -2 & \frac{2}{\sqrt{3}} & -\frac{1}{2}\\
        -\frac{1}{3} & \sqrt{3}-1 & -1 & 2 & \frac{1}{3} & -(1+\sqrt{3}) & 1\\
        \frac{1-\sqrt{3}}{1+\sqrt{3}} & \sqrt{3} & \sqrt{3}-1 & -\frac{2}{\sqrt{3}} & 1+\sqrt{3} & \sqrt{3} &-( 2+\sqrt{3})\\
        -\frac{1}{2} & 8-4\sqrt{3} & -\frac{4}{3} & 2 & -4 & 8+4\sqrt{3} &  -\frac{73}{6}
        \end{bmatrix}
        \]
        
        The chebyshev cost function is:
        	\[
	J=\frac{t_f-t_0}{2}\int_{t_0}^{t_f} \ell(x(t),u(t),t)\,dt \;+\; \phi(x(t_f))
        \]
        \[
        J \;\approx\; \frac{t_f-t_0}{2} \sum_{j=0}^{N} w_j \,\ell(x_j,u_j,t_j)
        \;+\; \phi(x_N),
        \qquad t_j = \frac{t_f-t_0}{2}\,\tau_j + \frac{t_f+t_0}{2}.
        \]
        	
        where $\phi(x(t_f))$ is the terminal cost and  $w_j$ are the Clenshaw-Curtis quadrature weights:

        \[
        w_{\mathrm{j_{even}}} =
        \begin{cases}
        \displaystyle
        \frac{2}{N}\!\left(
        1 - \sum_{n=1}^{\frac{N}{2}-1} \frac{2}{4n^{2}-1}\,
        \cos\!\Big(\tfrac{2 n j \pi}{N}\Big)
        -\frac{(-1)^{j}}{N^{2}-1}
        \right), & 1 \le j \le N-1, \\[2.0ex]
        \displaystyle \frac{1}{N^{2}-1}, & j=0\ \text{or}\ j=N \quad(\text{since \(N\) even}).
        \end{cases}
        \]

	\[
        w_{\mathrm{j_{odd}}} =
        \begin{cases}
        \displaystyle
        \frac{2}{N}\!\left(
        1 - \sum_{n=1}^{\frac{N}{2}-1} \frac{2}{4n^{2}-1}\,
        \cos\!\Big(\tfrac{2 n j \pi}{N}\Big)
        \right), & 1 \le j \le N-1, \\[2ex]
        \displaystyle \frac{1}{N^{2}}, & j=0\ \text{or}\ j=N.
        \end{cases}
        \]

\section*{Comparison of Methods}

To compare our different formulations for the NLP problem, we ran a series of simulations each with the drone beginning in a unique and perturbed starting state. In all cases, the drone goal state was to be vertically balanced and motionless at the point $(x,y,z) = (0, 0, 0)$ in three dimensional space. We initially ran a set of seven different simulations. The results for all the simulations were similar in both quality of solutions and timing results, so we present only four of those simulations here.  For each simulation, we computed the average time required to solve the NLP problem at each iteration. The quality of the solutions produced by each method was assessed by comparing the state and control graphs through time. All experiements were run on a Macbook Pro  3.49GHz Apple M2 chip with 8GB RAM. Code was implemented in Python 3.13 using CasADI 3.7.1. 
	
	\subsection*{NLP Solver}
	To solve our non-linear programming (NLP) problems we used the \texttt{ipopt} solver that comes installed with CasADi 3.7.1.  This solver requires an additional subroutine to  solve sparse matrix systems. We experimented with the \texttt{mumps}  solver that comes with CasADi, and also tried using the  \texttt{ma27} and  \texttt{ma57} solvers  from HSL (Harwell Subroutine Library) \cite{hsl}. All solvers were compiled with Apple clang version 17.0.0. The HSL \texttt{ma27} solver produced the most efficient solutions overall. All solvers and experiments were run with the same solver settings.
	\vspace{\baselineskip}
	\begin{python}
        ipopt_settings = {
			'ipopt.max_iter': 100,                  
			'ipopt.tol': 1e-3,                      	
			'ipopt.acceptable_tol': 3e-2,
			'ipopt.linear_solver': 'ma27',
		}
	\end{python}


\subsection*{Results}
We begin with our first simulation which requires the drone to perform a $45^{\circ}$ rotation about the $z$ axis to achieve the goal state. 
Figure (\ref{fig:state45z}) shows a graph of the drone's state overtime for each of our methods: orthagoal collocation, multiple shooter, and Chebyshev pseudospectral. The figures  (\ref{fig:statex1z1vx}), (\ref{fig:statey115dx}) and (\ref{fig:statehover}) show similar graphs for our other three simulations.  Comparison graphs of the control variables are given in figures (\ref{fig:control45z}), (\ref{fig:controlx1z1vx}), (\ref{fig:controly115dx}) and (\ref{fig:controlhover}). Finally, graphs comparing the CPU time for NLP calls throughout the simulations are given in figures (\ref{fig:time45z}), (\ref{fig:timex1z1vx}), (\ref{fig:timey115dx}) and (\ref{fig:timehover}). 
 
\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state45dz1.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state45dz3.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state45dz2.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{State data on a simulation requiring a $45^{\circ}$ rotation about the $z$ axis.}
	\label{fig:state45z}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{control45dz4.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{control45dz6.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{control45dz5.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{Control data on a simulation requiring a $45^{\circ}$ rotation about the $z$ axis.}
	\label{fig:control45z}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{time45dz.pdf}
	\caption{CPU time for simulation requiring a $45^{\circ}$ rotation about the $z$ axis.}
	\label{fig:time45z}
\end{figure}


\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statex1z1vx1.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statex1z1vx3.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statex1z1vx2.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{State data on a simulation with initial conditions: $x = 1$, $z=1$, $v_x = 0.5$ }
	\label{fig:statex1z1vx}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controlx1z1vx4.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controlx1z1vx6.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controlx1z1vx5.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{Control data on a simulation with initial conditions: $x = 1$, $z=1$, $v_x = 0.5$}
	\label{fig:controlx1z1vx}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{time45dz.pdf}
	\caption{CPU time for a simulation with initial conditions: $x = 1$, $z=1$, $v_x = 0.5$}
	\label{fig:timex1z1vx}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statey115dx1.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statey115dx3.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statey115dx2.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{State data on a simulation with initial conditions: $y = 1$,$15^{\circ}$ rotation about $x$ axis.}
	\label{fig:statey115dx}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controly115dx4.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controly115dx6.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controly115dx5.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{Control data on a simulation with initial conditions: $y = 1$,$15^{\circ}$ rotation about $x$ axis.}
	\label{fig:controly115dx}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{timey115dx.pdf}
	\caption{CPU time for simulation with initial conditions: $y = 1$,$15^{\circ}$ rotation about $x$ axis.}
	\label{fig:timey115dx}
\end{figure}




\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statehover1.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statehover3.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{statehover2.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{State data on a simulation with initial state equal to goal state.}
	\label{fig:statehover}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controlhover4.pdf}
		\caption{orthagonal collocation}
	\end{subfigure}%
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controlhover6.pdf}
		\caption{multiple shooter}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{controlhover5.pdf}
		\caption{Chebyshev pseudospectral}
	\end{subfigure}
	\caption{Control data on a simulation with initial state equal to goal state.}
	\label{fig:controlhover}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{timehover.pdf}
	\caption{CPU time for simulation with initial state equal to goal state.}
	\label{fig:timehover}
\end{figure}


All of the methods provide good quality solutions with state values that behaved smoothly and converged to the desired goal state. The graphs of control variables were generally smooth, but all methods occasionally constructed solutions where the  average thrust $\overline{P}$ seemed more irregular than required to reach the goal state.  Real world experiments on the drone will be needed to determine if solutions with these irregularities will negatively affect performance in practice.


\begin{table}[h!]	
	\begin{center}
		\begin{tabular}{ | l | c | c | c | } 
			\hline
			initial state & OC  & MS & CPS \\
			\hline
			$45^{\circ}$ rotation about $z$ axis & 0.063 &       0.056 & 0.002 \\ 
			$x = 1$, $z=1$, $v_x = 0.5$  & 0.059          &        0.046 & 0.003 \\ 
			$y = 1$,$15^{\circ}$ rotation about $x$ axis &0.063          &       0.06 & 0.004\\ 
				initial state equal to goal state & 0.062    &            0.056  & 0.002 \\ 
			\hline
		\end{tabular}
		\caption{Comparison of average CPU time in seconds for solution of NLP for a series of  simulations. Methods include orthagonal collocation (OC),  multiple shooter (MS), and Chebyshev pseudospectral method (CPS). }
		\label{table:CPU}
	\end{center}

\end{table}

 Our goal is to run our control algorithm at $50$Hz on the raspberry Pi 5. The CPU speed of the Pi is 2.4GHz while our experiments were run on a machine with a CPU speed of 3.49GHz. To meet our goal of 50Hz on the Pi we need a solution time on the experiment machine of less than $0.014$ seconds. Table (\ref{table:CPU}) summarizes the average CPU time for solution of the NLP problem for each simulation and each method.  The run times for the orthagonal collocation and multiple shooter are both too slow to meet our  $50$Hz target.  Additional changes such as reducing the length of the horizon or relaxing convergence criteria might improve these times somewhat, but they are unlikely to provide the performance needed for this application of NMPC.  The Chebyshev pseudospectral method is substantially faster and comfortably meets our $0.014$ solution time while providing solution graphs with comparable quality.

\section*{Conclusions}
We implemented three different formulations of the NPL problem for an NMPC algorithm controlling a thrust vector drone and compared their solution quality and relative efficiency. All methods produced good quality solutions while only the Chebyshev pseudospectral method provided solutions that are efficient enough to control the drone on a Raspberry Pi 5. Further real-world experiments are required to determine if the solutions produced provide good control in practice.
	
	
%	\nocite{*}
%	
\bibliographystyle{annotate}
\bibliography{references.bib}
\end{document}

